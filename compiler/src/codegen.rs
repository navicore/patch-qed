//! LLVM IR Code Generation via Text
//!
//! Generates LLVM IR as text (.ll files) and invokes clang to produce executables.
//! This approach is simpler and more portable than using FFI bindings (inkwell).

use crate::ir::{
    self, BinOp, CompareOp, IrFact, IrGoal, IrProgram, IrRelation, IrTerm, IrValue, TypeLayout,
};
use std::collections::HashMap;
use std::fmt::Write as _;

pub struct CodeGen {
    output: String,
    string_counter: usize,
    strings: HashMap<String, String>, // content -> label (for deduplication)
}

impl CodeGen {
    pub fn new() -> Self {
        CodeGen {
            output: String::new(),
            string_counter: 0,
            strings: HashMap::new(),
        }
    }

    /// Generate LLVM IR for a complete program (from AST)
    pub fn codegen_program(&mut self, program: &crate::ast::Program) -> Result<String, String> {
        // Lower AST to IR first
        let ir_program = ir::lower_to_ir(program);
        self.codegen_ir(&ir_program)
    }

    /// Generate LLVM IR from IR
    pub fn codegen_ir(&mut self, program: &IrProgram) -> Result<String, String> {
        // Header
        self.emit_header();

        // Runtime declarations
        self.emit_runtime_declarations();

        // Type definitions
        for typedef in &program.types {
            self.emit_type_def(typedef);
        }

        // String constants (collected during code generation)
        // Will be emitted at the end

        // Generate relation implementations
        for relation in &program.relations {
            self.emit_relation(relation);
        }

        // Generate query implementations
        for (i, query) in program.queries.iter().enumerate() {
            self.emit_query(i, query);
        }

        // Generate main function
        self.emit_main(&program.queries);

        // Emit string constants at the end
        self.emit_string_constants();

        Ok(self.output.clone())
    }

    fn emit_header(&mut self) {
        writeln!(self.output, "; QED Compiled Program").unwrap();
        writeln!(self.output, "; Generated by qedc").unwrap();
        writeln!(self.output).unwrap();
        writeln!(self.output, "target triple = \"arm64-apple-macosx14.0.0\"").unwrap();
        writeln!(self.output).unwrap();
    }

    /// Emit declarations for runtime functions
    fn emit_runtime_declarations(&mut self) {
        writeln!(self.output, "; QED Runtime Function Declarations").unwrap();
        writeln!(self.output).unwrap();

        // Arena functions
        writeln!(
            self.output,
            "declare ptr @qed_arena_new(i64)  ; Create new arena"
        )
        .unwrap();
        writeln!(
            self.output,
            "declare void @qed_arena_free(ptr)  ; Free arena"
        )
        .unwrap();
        writeln!(
            self.output,
            "declare ptr @qed_arena_alloc(ptr, i64, i64)  ; Allocate in arena"
        )
        .unwrap();
        writeln!(self.output).unwrap();

        // Table functions
        writeln!(
            self.output,
            "declare ptr @qed_table_new(i64)  ; Create new table"
        )
        .unwrap();
        writeln!(
            self.output,
            "declare void @qed_table_free(ptr)  ; Free table"
        )
        .unwrap();
        writeln!(
            self.output,
            "declare void @qed_table_insert(ptr, i64, ptr, ptr)  ; Insert into table"
        )
        .unwrap();
        writeln!(self.output).unwrap();

        // Print functions for output
        writeln!(
            self.output,
            "declare i32 @printf(ptr, ...)  ; Standard printf"
        )
        .unwrap();
        writeln!(self.output).unwrap();
    }

    fn emit_type_def(&mut self, typedef: &ir::IrTypeDef) {
        writeln!(self.output, "; Type: {}", typedef.name).unwrap();

        match &typedef.layout {
            TypeLayout::Struct {
                fields,
                size_bytes,
                align_bytes,
            } => {
                // Generate LLVM struct type
                let field_types: Vec<String> =
                    fields.iter().map(|(_, ty)| Self::llvm_type(ty)).collect();

                writeln!(
                    self.output,
                    "%struct.{} = type {{ {} }}  ; size={}, align={}",
                    typedef.name,
                    field_types.join(", "),
                    size_bytes,
                    align_bytes
                )
                .unwrap();
            }
            TypeLayout::Enum {
                variants,
                tag_size,
                max_variant_size,
            } => {
                // Generate tagged union
                writeln!(
                    self.output,
                    "%enum.{} = type {{ i{}, [{}  x i8] }}  ; variants: {:?}",
                    typedef.name,
                    tag_size * 8,
                    max_variant_size,
                    variants
                )
                .unwrap();
            }
        }
        writeln!(self.output).unwrap();
    }

    fn llvm_type(ty: &crate::ast::Type) -> String {
        match ty {
            crate::ast::Type::Named(name) => match name.as_str() {
                "Int" => "i64".to_string(),
                "String" => "ptr".to_string(), // pointer to string struct
                "Bool" => "i1".to_string(),
                _ => "ptr".to_string(), // pointer to user-defined struct
            },
            crate::ast::Type::List(_) => "ptr".to_string(),
            crate::ast::Type::Option(_) => "ptr".to_string(),
            crate::ast::Type::Product(types) => {
                let tys: Vec<_> = types.iter().map(Self::llvm_type).collect();
                format!("{{ {} }}", tys.join(", "))
            }
        }
    }

    fn emit_relation(&mut self, relation: &IrRelation) {
        writeln!(self.output, "; Relation: {}", relation.name).unwrap();

        // For now, emit a simple fact-checking function
        // This will iterate through facts and check for matches

        let arity = match &relation.signature {
            crate::ast::Type::Product(types) => types.len(),
            _ => 1,
        };

        // Emit facts as global data
        if !relation.facts.is_empty() {
            self.emit_facts_data(&relation.name, &relation.facts, arity);
        }

        // Emit the relation function that searches facts
        self.emit_relation_function(relation, arity);

        writeln!(self.output).unwrap();
    }

    fn emit_facts_data(&mut self, rel_name: &str, facts: &[IrFact], arity: usize) {
        // Emit each fact as a global constant
        for (i, fact) in facts.iter().enumerate() {
            let values: Vec<String> = fact
                .args
                .iter()
                .map(|v| self.emit_value_constant(v))
                .collect();

            writeln!(
                self.output,
                "@{}_fact_{} = private constant [{}  x i64] [{}]",
                rel_name,
                i,
                arity,
                values.join(", ")
            )
            .unwrap();
        }

        // Emit array of fact pointers
        let fact_ptrs: Vec<String> = (0..facts.len())
            .map(|i| format!("ptr @{}_fact_{}", rel_name, i))
            .collect();

        writeln!(
            self.output,
            "@{}_facts = private constant [{}  x ptr] [{}]",
            rel_name,
            facts.len(),
            fact_ptrs.join(", ")
        )
        .unwrap();

        writeln!(
            self.output,
            "@{}_facts_count = private constant i64 {}",
            rel_name,
            facts.len()
        )
        .unwrap();
    }

    fn emit_value_constant(&mut self, value: &IrValue) -> String {
        match value {
            IrValue::Int(n) => format!("i64 {}", n),
            IrValue::String(s) => {
                // Create a string constant and return a pointer-sized int
                let label = self.add_string(s);
                format!("i64 ptrtoint(ptr @{} to i64)", label)
            }
            IrValue::Struct { fields, .. } => {
                // For structs, we just emit field values inline for now
                // This is simplified - real impl would allocate struct
                if let Some(first) = fields.first() {
                    self.emit_value_constant(first)
                } else {
                    "i64 0".to_string()
                }
            }
            IrValue::Variant { .. } => "i64 0".to_string(), // Tag value
        }
    }

    fn emit_relation_function(&mut self, relation: &IrRelation, arity: usize) {
        // Generate a function that checks if arguments match any fact
        // Returns 1 if match found, 0 otherwise

        let params: Vec<String> = (0..arity).map(|i| format!("i64 %arg{}", i)).collect();

        writeln!(
            self.output,
            "define i32 @{}({}) {{",
            relation.name,
            params.join(", ")
        )
        .unwrap();
        writeln!(self.output, "entry:").unwrap();

        if relation.facts.is_empty() && relation.rules.is_empty() {
            // No facts or rules - always fails
            writeln!(self.output, "  ret i32 0").unwrap();
        } else if !relation.facts.is_empty() {
            // Check each fact
            writeln!(
                self.output,
                "  %count = load i64, ptr @{}_facts_count",
                relation.name
            )
            .unwrap();
            writeln!(self.output, "  br label %loop").unwrap();

            writeln!(self.output, "loop:").unwrap();
            writeln!(self.output, "  %i = phi i64 [0, %entry], [%next_i, %next]").unwrap();
            writeln!(self.output, "  %done = icmp uge i64 %i, %count").unwrap();
            writeln!(self.output, "  br i1 %done, label %fail, label %check").unwrap();

            writeln!(self.output, "check:").unwrap();
            writeln!(
                self.output,
                "  %fact_ptr = getelementptr [{}  x ptr], ptr @{}_facts, i64 0, i64 %i",
                relation.facts.len(),
                relation.name
            )
            .unwrap();
            writeln!(self.output, "  %fact = load ptr, ptr %fact_ptr").unwrap();

            // Check all arguments against the fact
            for arg_idx in 0..arity {
                writeln!(
                    self.output,
                    "  %val{} = getelementptr [{}  x i64], ptr %fact, i64 0, i64 {}",
                    arg_idx, arity, arg_idx
                )
                .unwrap();
                writeln!(
                    self.output,
                    "  %v{} = load i64, ptr %val{}",
                    arg_idx, arg_idx
                )
                .unwrap();
                writeln!(
                    self.output,
                    "  %match{} = icmp eq i64 %v{}, %arg{}",
                    arg_idx, arg_idx, arg_idx
                )
                .unwrap();
            }

            // Combine all matches with AND
            if arity > 1 {
                writeln!(self.output, "  %match_01 = and i1 %match0, %match1").unwrap();
                let mut prev_match = "%match_01".to_string();
                for arg_idx in 2..arity {
                    let new_match = format!("%match_0{}", arg_idx);
                    writeln!(
                        self.output,
                        "  {} = and i1 {}, %match{}",
                        new_match, prev_match, arg_idx
                    )
                    .unwrap();
                    prev_match = new_match;
                }
                writeln!(
                    self.output,
                    "  br i1 {}, label %success, label %next",
                    prev_match
                )
                .unwrap();
            } else {
                writeln!(self.output, "  br i1 %match0, label %success, label %next").unwrap();
            }

            writeln!(self.output, "next:").unwrap();
            writeln!(self.output, "  %next_i = add i64 %i, 1").unwrap();
            writeln!(self.output, "  br label %loop").unwrap();

            writeln!(self.output, "success:").unwrap();
            writeln!(self.output, "  ret i32 1").unwrap();

            writeln!(self.output, "fail:").unwrap();
            writeln!(self.output, "  ret i32 0").unwrap();
        } else {
            // Only rules - try each rule in order
            self.emit_rule_evaluation(relation, arity);
        }

        writeln!(self.output, "}}").unwrap();
    }

    /// Emit code to evaluate rules for a relation
    fn emit_rule_evaluation(&mut self, relation: &IrRelation, _arity: usize) {
        // For each rule, we try to match the head and evaluate the body
        // This is a simplified implementation that handles basic cases

        if relation.rules.is_empty() {
            writeln!(self.output, "  ret i32 0").unwrap();
            return;
        }

        // Try each rule in order
        for (rule_idx, rule) in relation.rules.iter().enumerate() {
            let rule_label = format!("rule_{}", rule_idx);
            let next_rule = if rule_idx + 1 < relation.rules.len() {
                format!("rule_{}", rule_idx + 1)
            } else {
                "fail".to_string()
            };

            if rule_idx == 0 {
                writeln!(self.output, "  br label %{}", rule_label).unwrap();
            }

            writeln!(self.output, "{}:", rule_label).unwrap();

            // Evaluate each goal in the rule body
            for (goal_idx, goal) in rule.body.iter().enumerate() {
                match goal {
                    IrGoal::Call {
                        relation: rel_name,
                        args,
                        ..
                    } => {
                        let arg_values: Vec<String> =
                            args.iter().map(|_| "i64 0".to_string()).collect();

                        writeln!(
                            self.output,
                            "  %rule{}_goal{} = call i32 @{}({})",
                            rule_idx,
                            goal_idx,
                            rel_name,
                            arg_values.join(", ")
                        )
                        .unwrap();

                        // Check if the goal succeeded
                        writeln!(
                            self.output,
                            "  %rule{}_check{} = icmp eq i32 %rule{}_goal{}, 0",
                            rule_idx, goal_idx, rule_idx, goal_idx
                        )
                        .unwrap();

                        // If goal failed, try next rule
                        let next_goal = if goal_idx + 1 < rule.body.len() {
                            format!("rule{}_body{}", rule_idx, goal_idx + 1)
                        } else {
                            "success".to_string()
                        };

                        writeln!(
                            self.output,
                            "  br i1 %rule{}_check{}, label %{}, label %{}",
                            rule_idx, goal_idx, next_rule, next_goal
                        )
                        .unwrap();

                        if goal_idx + 1 < rule.body.len() {
                            writeln!(self.output, "rule{}_body{}:", rule_idx, goal_idx + 1)
                                .unwrap();
                        }
                    }
                    IrGoal::Unify { .. } | IrGoal::Compare { .. } => {
                        // For now, skip unification and comparison goals
                        writeln!(
                            self.output,
                            "  ; TODO: handle unify/compare in rule {}, goal {}",
                            rule_idx, goal_idx
                        )
                        .unwrap();
                    }
                }
            }

            // If we get here without any goals, the rule succeeds
            if rule.body.is_empty() {
                writeln!(self.output, "  br label %success").unwrap();
            }
        }

        writeln!(self.output, "success:").unwrap();
        writeln!(self.output, "  ret i32 1").unwrap();

        writeln!(self.output, "fail:").unwrap();
        writeln!(self.output, "  ret i32 0").unwrap();
    }

    fn emit_query(&mut self, index: usize, query: &ir::IrQuery) {
        writeln!(self.output, "; Query {}", index).unwrap();

        writeln!(self.output, "define i32 @query_{}() {{", index).unwrap();
        writeln!(self.output, "entry:").unwrap();

        let mut var_counter = 0;

        // For each goal in the query, emit a call
        for (i, goal) in query.goals.iter().enumerate() {
            match goal {
                IrGoal::Call { relation, args, .. } => {
                    // Emit code to evaluate each argument
                    let mut arg_values = Vec::new();
                    for (arg_idx, arg) in args.iter().enumerate() {
                        let (code, value) = self.emit_term_to_i64(
                            arg,
                            &format!("q{}_g{}_a{}", index, i, arg_idx),
                            &mut var_counter,
                        );
                        if !code.is_empty() {
                            write!(self.output, "{}", code).unwrap();
                        }
                        arg_values.push(format!("i64 {}", value));
                    }

                    writeln!(
                        self.output,
                        "  %result_{} = call i32 @{}({})",
                        i,
                        relation,
                        arg_values.join(", ")
                    )
                    .unwrap();

                    // Check result and branch
                    writeln!(self.output, "  %check_{} = icmp eq i32 %result_{}, 0", i, i).unwrap();
                    writeln!(
                        self.output,
                        "  br i1 %check_{}, label %fail, label %goal_{}",
                        i,
                        i + 1
                    )
                    .unwrap();
                    writeln!(self.output, "goal_{}:", i + 1).unwrap();
                }
                _ => {
                    writeln!(self.output, "  ; TODO: handle goal type").unwrap();
                }
            }
        }

        // Return success if we got here
        writeln!(self.output, "  ret i32 1").unwrap();

        writeln!(self.output, "fail:").unwrap();
        writeln!(self.output, "  ret i32 0").unwrap();

        writeln!(self.output, "}}").unwrap();
        writeln!(self.output).unwrap();
    }

    /// Emit code to evaluate a term to an i64 value
    /// Returns (code_to_emit, value_or_register)
    fn emit_term_to_i64(
        &mut self,
        term: &IrTerm,
        prefix: &str,
        counter: &mut usize,
    ) -> (String, String) {
        match term {
            IrTerm::Value(v) => self.emit_value_to_i64(v),
            IrTerm::Var(_) => {
                // For now, variables in queries are unbound (match any)
                // Return 0 as a placeholder - proper unification would require more work
                (String::new(), "0".to_string())
            }
            _ => (String::new(), "0".to_string()),
        }
    }

    /// Emit code to get an i64 representation of a value
    fn emit_value_to_i64(&mut self, value: &IrValue) -> (String, String) {
        match value {
            IrValue::Int(n) => (String::new(), n.to_string()),
            IrValue::String(s) => {
                // Create a string constant and return its address as i64
                let label = self.add_string(s);
                (String::new(), format!("ptrtoint(ptr @{} to i64)", label))
            }
            IrValue::Struct { fields, .. } => {
                // For structs, we return the first field's value (simplified)
                // Proper struct comparison would need more work
                if let Some(first) = fields.first() {
                    self.emit_value_to_i64(first)
                } else {
                    (String::new(), "0".to_string())
                }
            }
            IrValue::Variant { .. } => (String::new(), "0".to_string()),
        }
    }

    /// Emit main function
    fn emit_main(&mut self, queries: &[ir::IrQuery]) {
        // Create format strings for output
        let success_label = self.add_string("Query %d: true\\n");
        let fail_label = self.add_string("Query %d: false\\n");

        writeln!(self.output, "; Main entry point").unwrap();
        writeln!(self.output, "define i32 @main() {{").unwrap();
        writeln!(self.output, "entry:").unwrap();

        // Initialize arena
        writeln!(
            self.output,
            "  %arena = call ptr @qed_arena_new(i64 1048576)  ; 1MB arena"
        )
        .unwrap();

        // Execute each query and print result
        for (i, _) in queries.iter().enumerate() {
            writeln!(self.output, "  %q{} = call i32 @query_{}()", i, i).unwrap();
            writeln!(self.output, "  %q{}_success = icmp ne i32 %q{}, 0", i, i).unwrap();
            writeln!(
                self.output,
                "  br i1 %q{}_success, label %q{}_true, label %q{}_false",
                i, i, i
            )
            .unwrap();

            writeln!(self.output, "q{}_true:", i).unwrap();
            writeln!(
                self.output,
                "  call i32 (ptr, ...) @printf(ptr @{}, i32 {})",
                success_label, i
            )
            .unwrap();
            writeln!(self.output, "  br label %q{}_done", i).unwrap();

            writeln!(self.output, "q{}_false:", i).unwrap();
            writeln!(
                self.output,
                "  call i32 (ptr, ...) @printf(ptr @{}, i32 {})",
                fail_label, i
            )
            .unwrap();
            writeln!(self.output, "  br label %q{}_done", i).unwrap();

            writeln!(self.output, "q{}_done:", i).unwrap();
        }

        // Free arena
        writeln!(self.output, "  call void @qed_arena_free(ptr %arena)").unwrap();

        writeln!(self.output, "  ret i32 0").unwrap();
        writeln!(self.output, "}}").unwrap();
    }

    /// Add a string constant and return its label (deduplicates identical strings)
    fn add_string(&mut self, content: &str) -> String {
        if let Some(label) = self.strings.get(content) {
            return label.clone();
        }
        let label = format!(".str.{}", self.string_counter);
        self.string_counter += 1;
        self.strings.insert(content.to_string(), label.clone());
        label
    }

    fn emit_string_constants(&mut self) {
        if self.strings.is_empty() {
            return;
        }

        writeln!(self.output).unwrap();
        writeln!(self.output, "; String constants").unwrap();

        // Sort strings by label for deterministic output
        let mut sorted: Vec<_> = self.strings.iter().collect();
        sorted.sort_by_key(|(_, label)| *label);

        for (content, label) in sorted {
            // Escape LLVM IR string: replace \n with \0A
            let escaped = content.replace("\\n", "\\0A");
            // Calculate actual length after escape processing
            // Count actual bytes: each \XX is 1 byte, regular chars are 1 byte
            let len = Self::llvm_string_len(&escaped) + 1; // +1 for null terminator
            writeln!(
                self.output,
                "@{} = private constant [{} x i8] c\"{}\\00\"",
                label, len, escaped
            )
            .unwrap();
        }
    }

    /// Calculate the actual byte length of an LLVM IR escaped string
    fn llvm_string_len(s: &str) -> usize {
        let mut len = 0;
        let mut chars = s.chars().peekable();
        while let Some(c) = chars.next() {
            if c == '\\' {
                // Escape sequence - consume two hex digits, counts as 1 byte
                chars.next();
                chars.next();
                len += 1;
            } else {
                len += 1;
            }
        }
        len
    }
}

impl Default for CodeGen {
    fn default() -> Self {
        Self::new()
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::ast::Program;

    #[test]
    fn test_codegen_basic() {
        let mut codegen = CodeGen::new();
        let program = Program { items: vec![] };

        let ir = codegen.codegen_program(&program);
        assert!(ir.is_ok());

        let ir_text = ir.unwrap();
        assert!(ir_text.contains("@main"));
        assert!(ir_text.contains("@qed_arena_new"));
    }

    #[test]
    fn test_codegen_with_types() {
        use crate::parser;

        let source = r#"
            type Person = person(name: String, age: Int)
        "#;
        let program = parser::parse(source).expect("Parse failed");

        let mut codegen = CodeGen::new();
        let ir = codegen.codegen_program(&program);
        assert!(ir.is_ok());

        let ir_text = ir.unwrap();
        assert!(ir_text.contains("%struct.Person"));
    }

    #[test]
    fn test_codegen_with_relation() {
        use crate::parser;

        let source = r#"
            type Person = person(name: String, age: Int)
            rel parent: Person × Person
            parent(person("Alice", 45), person("Bob", 20)).
        "#;
        let program = parser::parse(source).expect("Parse failed");

        let mut codegen = CodeGen::new();
        let ir = codegen.codegen_program(&program);
        assert!(ir.is_ok());

        let ir_text = ir.unwrap();
        assert!(ir_text.contains("define i32 @parent"));
        assert!(ir_text.contains("@parent_fact_0"));
    }

    #[test]
    fn test_codegen_with_query() {
        use crate::parser;

        let source = r#"
            type Person = person(name: String, age: Int)
            rel ancestor: Person × Person
            ?- ancestor(X, Y).
        "#;
        let program = parser::parse(source).expect("Parse failed");

        let mut codegen = CodeGen::new();
        let ir = codegen.codegen_program(&program);
        assert!(ir.is_ok());

        let ir_text = ir.unwrap();
        assert!(ir_text.contains("define i32 @query_0"));
    }
}
