//! LLVM IR Code Generation via Text
//!
//! Generates LLVM IR as text (.ll files) and invokes clang to produce executables.
//! This approach is simpler and more portable than using FFI bindings (inkwell).

use crate::ir::{
    self, BinOp, CompareOp, IrFact, IrGoal, IrProgram, IrRelation, IrTerm, IrValue, TypeLayout,
};
use std::collections::HashMap;
use std::fmt::{self, Write as _};

/// Result type for code generation operations
type CodeGenResult = Result<(), fmt::Error>;

pub struct CodeGen {
    output: String,
    string_counter: usize,
    strings: HashMap<String, String>, // content -> label (for deduplication)
}

impl CodeGen {
    pub fn new() -> Self {
        CodeGen {
            output: String::new(),
            string_counter: 0,
            strings: HashMap::new(),
        }
    }

    /// Generate LLVM IR for a complete program (from AST)
    pub fn codegen_program(&mut self, program: &crate::ast::Program) -> Result<String, String> {
        // Lower AST to IR first
        let ir_program = ir::lower_to_ir(program);
        self.codegen_ir(&ir_program)
    }

    /// Generate LLVM IR from IR
    pub fn codegen_ir(&mut self, program: &IrProgram) -> Result<String, String> {
        self.codegen_ir_inner(program)
            .map_err(|e| format!("Code generation failed: {}", e))?;
        Ok(self.output.clone())
    }

    fn codegen_ir_inner(&mut self, program: &IrProgram) -> CodeGenResult {
        // Header
        self.emit_header()?;

        // Runtime declarations
        self.emit_runtime_declarations()?;

        // Type definitions
        for typedef in &program.types {
            self.emit_type_def(typedef)?;
        }

        // Generate relation implementations
        for relation in &program.relations {
            self.emit_relation(relation)?;
        }

        // Generate query implementations
        for (i, query) in program.queries.iter().enumerate() {
            self.emit_query(i, query)?;
        }

        // Generate main function
        self.emit_main(&program.queries)?;

        // Emit string constants at the end
        self.emit_string_constants()?;

        Ok(())
    }

    fn emit_header(&mut self) -> CodeGenResult {
        writeln!(self.output, "; QED Compiled Program")?;
        writeln!(self.output, "; Generated by qedc")?;
        writeln!(self.output)?;

        // Detect target triple at compile time
        let target = Self::detect_target_triple();
        writeln!(self.output, "target triple = \"{}\"", target)?;
        writeln!(self.output)?;
        Ok(())
    }

    /// Detect the target triple for the current platform
    fn detect_target_triple() -> &'static str {
        #[cfg(all(target_arch = "aarch64", target_os = "macos"))]
        {
            "arm64-apple-macosx14.0.0"
        }
        #[cfg(all(target_arch = "x86_64", target_os = "macos"))]
        {
            "x86_64-apple-macosx14.0.0"
        }
        #[cfg(all(target_arch = "x86_64", target_os = "linux"))]
        {
            "x86_64-unknown-linux-gnu"
        }
        #[cfg(all(target_arch = "aarch64", target_os = "linux"))]
        {
            "aarch64-unknown-linux-gnu"
        }
        #[cfg(not(any(
            all(target_arch = "aarch64", target_os = "macos"),
            all(target_arch = "x86_64", target_os = "macos"),
            all(target_arch = "x86_64", target_os = "linux"),
            all(target_arch = "aarch64", target_os = "linux"),
        )))]
        {
            // Fallback for other platforms
            "unknown-unknown-unknown"
        }
    }

    /// Emit declarations for runtime functions
    fn emit_runtime_declarations(&mut self) -> CodeGenResult {
        writeln!(self.output, "; QED Runtime Function Declarations")?;
        writeln!(self.output)?;

        // Arena functions
        writeln!(
            self.output,
            "declare ptr @qed_arena_new(i64)  ; Create new arena"
        )?;
        writeln!(
            self.output,
            "declare void @qed_arena_free(ptr)  ; Free arena"
        )?;
        writeln!(
            self.output,
            "declare ptr @qed_arena_alloc(ptr, i64, i64)  ; Allocate in arena"
        )?;
        writeln!(self.output)?;

        // Table functions
        writeln!(
            self.output,
            "declare ptr @qed_table_new(i64)  ; Create new table"
        )?;
        writeln!(
            self.output,
            "declare void @qed_table_free(ptr)  ; Free table"
        )?;
        writeln!(
            self.output,
            "declare void @qed_table_insert(ptr, i64, ptr, ptr)  ; Insert into table"
        )?;
        writeln!(self.output)?;

        // Print functions for output
        writeln!(
            self.output,
            "declare i32 @printf(ptr, ...)  ; Standard printf"
        )?;
        writeln!(self.output)?;
        Ok(())
    }

    fn emit_type_def(&mut self, typedef: &ir::IrTypeDef) -> CodeGenResult {
        writeln!(self.output, "; Type: {}", typedef.name)?;

        match &typedef.layout {
            TypeLayout::Struct {
                fields,
                size_bytes,
                align_bytes,
            } => {
                // Generate LLVM struct type
                let field_types: Vec<String> =
                    fields.iter().map(|(_, ty)| Self::llvm_type(ty)).collect();

                writeln!(
                    self.output,
                    "%struct.{} = type {{ {} }}  ; size={}, align={}",
                    typedef.name,
                    field_types.join(", "),
                    size_bytes,
                    align_bytes
                )?;
            }
            TypeLayout::Enum {
                variants,
                tag_size,
                max_variant_size,
            } => {
                // Generate tagged union
                writeln!(
                    self.output,
                    "%enum.{} = type {{ i{}, [{}  x i8] }}  ; variants: {:?}",
                    typedef.name,
                    tag_size * 8,
                    max_variant_size,
                    variants
                )?;
            }
        }
        writeln!(self.output)?;
        Ok(())
    }

    fn llvm_type(ty: &crate::ast::Type) -> String {
        match ty {
            crate::ast::Type::Named(name) => match name.as_str() {
                "Int" => "i64".to_string(),
                "String" => "ptr".to_string(), // pointer to string struct
                "Bool" => "i1".to_string(),
                _ => "ptr".to_string(), // pointer to user-defined struct
            },
            crate::ast::Type::List(_) => "ptr".to_string(),
            crate::ast::Type::Option(_) => "ptr".to_string(),
            crate::ast::Type::Product(types) => {
                let tys: Vec<_> = types.iter().map(Self::llvm_type).collect();
                format!("{{ {} }}", tys.join(", "))
            }
        }
    }

    fn emit_relation(&mut self, relation: &IrRelation) -> CodeGenResult {
        writeln!(self.output, "; Relation: {}", relation.name)?;

        // Calculate flattened arity from actual facts (structs expand to multiple i64s)
        let flat_arity = if let Some(first_fact) = relation.facts.first() {
            first_fact
                .args
                .iter()
                .map(Self::value_flat_size)
                .sum::<usize>()
        } else {
            // Fallback to type signature arity if no facts
            match &relation.signature {
                crate::ast::Type::Product(types) => types.len(),
                _ => 1,
            }
        };

        // Emit facts as global data
        if !relation.facts.is_empty() {
            self.emit_facts_data(&relation.name, &relation.facts, flat_arity)?;
        }

        // Emit the relation function that searches facts
        self.emit_relation_function(relation, flat_arity)?;

        writeln!(self.output)?;
        Ok(())
    }

    fn emit_facts_data(
        &mut self,
        rel_name: &str,
        facts: &[IrFact],
        _arity: usize,
    ) -> CodeGenResult {
        // Emit each fact as a global constant
        // Flatten struct fields so all values are compared properly
        for (i, fact) in facts.iter().enumerate() {
            let values: Vec<String> = fact
                .args
                .iter()
                .flat_map(|v| self.emit_value_constants(v))
                .collect();
            let flat_arity = values.len();

            writeln!(
                self.output,
                "@{}_fact_{} = private constant [{}  x i64] [{}]",
                rel_name,
                i,
                flat_arity,
                values.join(", ")
            )?;
        }

        // Emit array of fact pointers
        let fact_ptrs: Vec<String> = (0..facts.len())
            .map(|i| format!("ptr @{}_fact_{}", rel_name, i))
            .collect();

        writeln!(
            self.output,
            "@{}_facts = private constant [{}  x ptr] [{}]",
            rel_name,
            facts.len(),
            fact_ptrs.join(", ")
        )?;

        writeln!(
            self.output,
            "@{}_facts_count = private constant i64 {}",
            rel_name,
            facts.len()
        )?;
        Ok(())
    }

    /// Emit a value constant, returning a list of i64 values (flattened for structs)
    fn emit_value_constants(&mut self, value: &IrValue) -> Vec<String> {
        match value {
            IrValue::Int(n) => vec![format!("i64 {}", n)],
            IrValue::String(s) => {
                // Create a string constant and return a pointer-sized int
                let label = self.add_string(s);
                vec![format!("i64 ptrtoint(ptr @{} to i64)", label)]
            }
            IrValue::Struct { fields, .. } => {
                // Flatten all struct fields into i64 values
                fields
                    .iter()
                    .flat_map(|f| self.emit_value_constants(f))
                    .collect()
            }
            IrValue::Variant { .. } => vec!["i64 0".to_string()], // Tag value
        }
    }

    /// Count how many i64 values a value will produce when flattened
    fn value_flat_size(value: &IrValue) -> usize {
        match value {
            IrValue::Int(_) => 1,
            IrValue::String(_) => 1,
            IrValue::Struct { fields, .. } => fields.iter().map(Self::value_flat_size).sum(),
            IrValue::Variant { .. } => 1,
        }
    }

    fn emit_relation_function(&mut self, relation: &IrRelation, arity: usize) -> CodeGenResult {
        // Generate a function that checks if arguments match any fact
        // Returns 1 if match found, 0 otherwise

        let params: Vec<String> = (0..arity).map(|i| format!("i64 %arg{}", i)).collect();

        writeln!(
            self.output,
            "define i32 @{}({}) {{",
            relation.name,
            params.join(", ")
        )?;
        writeln!(self.output, "entry:")?;

        if relation.facts.is_empty() && relation.rules.is_empty() {
            // No facts or rules - always fails
            writeln!(self.output, "  ret i32 0")?;
        } else if !relation.facts.is_empty() {
            // Check each fact
            writeln!(
                self.output,
                "  %count = load i64, ptr @{}_facts_count",
                relation.name
            )?;
            writeln!(self.output, "  br label %loop")?;

            writeln!(self.output, "loop:")?;
            writeln!(self.output, "  %i = phi i64 [0, %entry], [%next_i, %next]")?;
            writeln!(self.output, "  %done = icmp uge i64 %i, %count")?;
            writeln!(self.output, "  br i1 %done, label %fail, label %check")?;

            writeln!(self.output, "check:")?;
            writeln!(
                self.output,
                "  %fact_ptr = getelementptr [{}  x ptr], ptr @{}_facts, i64 0, i64 %i",
                relation.facts.len(),
                relation.name
            )?;
            writeln!(self.output, "  %fact = load ptr, ptr %fact_ptr")?;

            // Check all arguments against the fact
            for arg_idx in 0..arity {
                writeln!(
                    self.output,
                    "  %val{} = getelementptr [{}  x i64], ptr %fact, i64 0, i64 {}",
                    arg_idx, arity, arg_idx
                )?;
                writeln!(
                    self.output,
                    "  %v{} = load i64, ptr %val{}",
                    arg_idx, arg_idx
                )?;
                writeln!(
                    self.output,
                    "  %match{} = icmp eq i64 %v{}, %arg{}",
                    arg_idx, arg_idx, arg_idx
                )?;
            }

            // Combine all matches with AND
            if arity == 0 {
                // Zero-arity relation: fact always matches (no arguments to check)
                writeln!(self.output, "  br label %success")?;
            } else if arity == 1 {
                writeln!(self.output, "  br i1 %match0, label %success, label %next")?;
            } else {
                writeln!(self.output, "  %match_all_1 = and i1 %match0, %match1")?;
                let mut prev_match = "%match_all_1".to_string();
                for arg_idx in 2..arity {
                    let new_match = format!("%match_all_{}", arg_idx);
                    writeln!(
                        self.output,
                        "  {} = and i1 {}, %match{}",
                        new_match, prev_match, arg_idx
                    )?;
                    prev_match = new_match;
                }
                writeln!(
                    self.output,
                    "  br i1 {}, label %success, label %next",
                    prev_match
                )?;
            }

            writeln!(self.output, "next:")?;
            writeln!(self.output, "  %next_i = add i64 %i, 1")?;
            writeln!(self.output, "  br label %loop")?;

            writeln!(self.output, "success:")?;
            writeln!(self.output, "  ret i32 1")?;

            writeln!(self.output, "fail:")?;
            writeln!(self.output, "  ret i32 0")?;
        } else {
            // Only rules - try each rule in order
            self.emit_rule_evaluation(relation, arity)?;
        }

        writeln!(self.output, "}}")?;
        Ok(())
    }

    /// Emit code to evaluate rules for a relation
    fn emit_rule_evaluation(&mut self, relation: &IrRelation, _arity: usize) -> CodeGenResult {
        // For each rule, we try to match the head and evaluate the body
        // This is a simplified implementation that handles basic cases

        if relation.rules.is_empty() {
            writeln!(self.output, "  ret i32 0")?;
            return Ok(());
        }

        // Try each rule in order
        for (rule_idx, rule) in relation.rules.iter().enumerate() {
            let rule_label = format!("rule_{}", rule_idx);
            let next_rule = if rule_idx + 1 < relation.rules.len() {
                format!("rule_{}", rule_idx + 1)
            } else {
                "fail".to_string()
            };

            if rule_idx == 0 {
                writeln!(self.output, "  br label %{}", rule_label)?;
            }

            writeln!(self.output, "{}:", rule_label)?;

            // Evaluate each goal in the rule body
            for (goal_idx, goal) in rule.body.iter().enumerate() {
                match goal {
                    IrGoal::Call {
                        relation: rel_name,
                        args,
                        ..
                    } => {
                        let arg_values: Vec<String> =
                            args.iter().map(|_| "i64 0".to_string()).collect();

                        writeln!(
                            self.output,
                            "  %rule{}_goal{} = call i32 @{}({})",
                            rule_idx,
                            goal_idx,
                            rel_name,
                            arg_values.join(", ")
                        )?;

                        // Check if the goal succeeded
                        writeln!(
                            self.output,
                            "  %rule{}_check{} = icmp eq i32 %rule{}_goal{}, 0",
                            rule_idx, goal_idx, rule_idx, goal_idx
                        )?;

                        // If goal failed, try next rule
                        let next_goal = if goal_idx + 1 < rule.body.len() {
                            format!("rule{}_body{}", rule_idx, goal_idx + 1)
                        } else {
                            "success".to_string()
                        };

                        writeln!(
                            self.output,
                            "  br i1 %rule{}_check{}, label %{}, label %{}",
                            rule_idx, goal_idx, next_rule, next_goal
                        )?;

                        if goal_idx + 1 < rule.body.len() {
                            writeln!(self.output, "rule{}_body{}:", rule_idx, goal_idx + 1)?;
                        }
                    }
                    IrGoal::Unify { .. } | IrGoal::Compare { .. } => {
                        // For now, skip unification and comparison goals
                        writeln!(
                            self.output,
                            "  ; TODO: handle unify/compare in rule {}, goal {}",
                            rule_idx, goal_idx
                        )?;
                    }
                }
            }

            // If we get here without any goals, the rule succeeds
            if rule.body.is_empty() {
                writeln!(self.output, "  br label %success")?;
            }
        }

        writeln!(self.output, "success:")?;
        writeln!(self.output, "  ret i32 1")?;

        writeln!(self.output, "fail:")?;
        writeln!(self.output, "  ret i32 0")?;
        Ok(())
    }

    fn emit_query(&mut self, index: usize, query: &ir::IrQuery) -> CodeGenResult {
        writeln!(self.output, "; Query {}", index)?;

        writeln!(self.output, "define i32 @query_{}() {{", index)?;
        writeln!(self.output, "entry:")?;

        // For each goal in the query, emit a call
        for (i, goal) in query.goals.iter().enumerate() {
            match goal {
                IrGoal::Call { relation, args, .. } => {
                    // Emit code to evaluate each argument (flattening structs)
                    let arg_values: Vec<String> = args
                        .iter()
                        .flat_map(|arg| self.emit_term_to_i64s(arg))
                        .map(|v| format!("i64 {}", v))
                        .collect();

                    writeln!(
                        self.output,
                        "  %result_{} = call i32 @{}({})",
                        i,
                        relation,
                        arg_values.join(", ")
                    )?;

                    // Check result and branch
                    writeln!(self.output, "  %check_{} = icmp eq i32 %result_{}, 0", i, i)?;
                    writeln!(
                        self.output,
                        "  br i1 %check_{}, label %fail, label %goal_{}",
                        i,
                        i + 1
                    )?;
                    writeln!(self.output, "goal_{}:", i + 1)?;
                }
                _ => {
                    writeln!(self.output, "  ; TODO: handle goal type")?;
                }
            }
        }

        // Return success if we got here
        writeln!(self.output, "  ret i32 1")?;

        writeln!(self.output, "fail:")?;
        writeln!(self.output, "  ret i32 0")?;

        writeln!(self.output, "}}")?;
        writeln!(self.output)?;
        Ok(())
    }

    /// Emit code to evaluate a term to i64 values (flattened for structs)
    fn emit_term_to_i64s(&mut self, term: &IrTerm) -> Vec<String> {
        match term {
            IrTerm::Value(v) => self.emit_values_to_i64(v),
            IrTerm::Var(_) => {
                // For now, variables in queries are unbound (match any)
                // Return 0 as a placeholder - proper unification would require more work
                vec!["0".to_string()]
            }
            _ => vec!["0".to_string()],
        }
    }

    /// Emit code to get i64 representations of a value (flattened for structs)
    fn emit_values_to_i64(&mut self, value: &IrValue) -> Vec<String> {
        match value {
            IrValue::Int(n) => vec![n.to_string()],
            IrValue::String(s) => {
                // Create a string constant and return its address as i64
                let label = self.add_string(s);
                vec![format!("ptrtoint(ptr @{} to i64)", label)]
            }
            IrValue::Struct { fields, .. } => {
                // Flatten all struct fields
                fields
                    .iter()
                    .flat_map(|f| self.emit_values_to_i64(f))
                    .collect()
            }
            IrValue::Variant { .. } => vec!["0".to_string()],
        }
    }

    /// Emit main function
    fn emit_main(&mut self, queries: &[ir::IrQuery]) -> CodeGenResult {
        // Create format strings for output
        let success_label = self.add_string("Query %d: true\\n");
        let fail_label = self.add_string("Query %d: false\\n");

        writeln!(self.output, "; Main entry point")?;
        writeln!(self.output, "define i32 @main() {{")?;
        writeln!(self.output, "entry:")?;

        // Initialize arena
        writeln!(
            self.output,
            "  %arena = call ptr @qed_arena_new(i64 1048576)  ; 1MB arena"
        )?;

        // Execute each query and print result
        for (i, _) in queries.iter().enumerate() {
            writeln!(self.output, "  %q{} = call i32 @query_{}()", i, i)?;
            writeln!(self.output, "  %q{}_success = icmp ne i32 %q{}, 0", i, i)?;
            writeln!(
                self.output,
                "  br i1 %q{}_success, label %q{}_true, label %q{}_false",
                i, i, i
            )?;

            writeln!(self.output, "q{}_true:", i)?;
            writeln!(
                self.output,
                "  call i32 (ptr, ...) @printf(ptr @{}, i32 {})",
                success_label, i
            )?;
            writeln!(self.output, "  br label %q{}_done", i)?;

            writeln!(self.output, "q{}_false:", i)?;
            writeln!(
                self.output,
                "  call i32 (ptr, ...) @printf(ptr @{}, i32 {})",
                fail_label, i
            )?;
            writeln!(self.output, "  br label %q{}_done", i)?;

            writeln!(self.output, "q{}_done:", i)?;
        }

        // Free arena
        writeln!(self.output, "  call void @qed_arena_free(ptr %arena)")?;

        writeln!(self.output, "  ret i32 0")?;
        writeln!(self.output, "}}")?;
        Ok(())
    }

    /// Add a string constant and return its label (deduplicates identical strings)
    fn add_string(&mut self, content: &str) -> String {
        if let Some(label) = self.strings.get(content) {
            return label.clone();
        }
        let label = format!(".str.{}", self.string_counter);
        self.string_counter += 1;
        self.strings.insert(content.to_string(), label.clone());
        label
    }

    fn emit_string_constants(&mut self) -> CodeGenResult {
        if self.strings.is_empty() {
            return Ok(());
        }

        writeln!(self.output)?;
        writeln!(self.output, "; String constants")?;

        // Sort strings by label for deterministic output
        let mut sorted: Vec<_> = self.strings.iter().collect();
        sorted.sort_by_key(|(_, label)| *label);

        for (content, label) in sorted {
            // Escape LLVM IR string: replace \n with \0A
            let escaped = content.replace("\\n", "\\0A");
            // Calculate actual length after escape processing
            // Count actual bytes: each \XX is 1 byte, regular chars are 1 byte
            let len = Self::llvm_string_len(&escaped) + 1; // +1 for null terminator
            writeln!(
                self.output,
                "@{} = private constant [{} x i8] c\"{}\\00\"",
                label, len, escaped
            )?;
        }
        Ok(())
    }

    /// Calculate the actual byte length of an LLVM IR escaped string
    fn llvm_string_len(s: &str) -> usize {
        let mut len = 0;
        let mut chars = s.chars().peekable();
        while let Some(c) = chars.next() {
            if c == '\\' {
                // Escape sequence - consume two hex digits, counts as 1 byte
                chars.next();
                chars.next();
                len += 1;
            } else {
                len += 1;
            }
        }
        len
    }
}

impl Default for CodeGen {
    fn default() -> Self {
        Self::new()
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::ast::Program;

    #[test]
    fn test_codegen_basic() {
        let mut codegen = CodeGen::new();
        let program = Program { items: vec![] };

        let ir = codegen.codegen_program(&program);
        assert!(ir.is_ok());

        let ir_text = ir.unwrap();
        assert!(ir_text.contains("@main"));
        assert!(ir_text.contains("@qed_arena_new"));
    }

    #[test]
    fn test_codegen_with_types() {
        use crate::parser;

        let source = r#"
            type Person = person(name: String, age: Int)
        "#;
        let program = parser::parse(source).expect("Parse failed");

        let mut codegen = CodeGen::new();
        let ir = codegen.codegen_program(&program);
        assert!(ir.is_ok());

        let ir_text = ir.unwrap();
        assert!(ir_text.contains("%struct.Person"));
    }

    #[test]
    fn test_codegen_with_relation() {
        use crate::parser;

        let source = r#"
            type Person = person(name: String, age: Int)
            rel parent: Person × Person
            parent(person("Alice", 45), person("Bob", 20)).
        "#;
        let program = parser::parse(source).expect("Parse failed");

        let mut codegen = CodeGen::new();
        let ir = codegen.codegen_program(&program);
        assert!(ir.is_ok());

        let ir_text = ir.unwrap();
        assert!(ir_text.contains("define i32 @parent"));
        assert!(ir_text.contains("@parent_fact_0"));
    }

    #[test]
    fn test_codegen_with_query() {
        use crate::parser;

        let source = r#"
            type Person = person(name: String, age: Int)
            rel ancestor: Person × Person
            ?- ancestor(X, Y).
        "#;
        let program = parser::parse(source).expect("Parse failed");

        let mut codegen = CodeGen::new();
        let ir = codegen.codegen_program(&program);
        assert!(ir.is_ok());

        let ir_text = ir.unwrap();
        assert!(ir_text.contains("define i32 @query_0"));
    }

    #[test]
    fn test_codegen_struct_flattening() {
        use crate::parser;

        // Test that struct fields are properly flattened for comparison
        let source = r#"
            type Person = person(name: String, age: Int)
            rel parent: Person × Person
            parent(person("Alice", 45), person("Bob", 20)).
            ?- parent(person("Alice", 45), person("Bob", 20)).
        "#;
        let program = parser::parse(source).expect("Parse failed");

        let mut codegen = CodeGen::new();
        let ir = codegen.codegen_program(&program);
        assert!(ir.is_ok());

        let ir_text = ir.unwrap();

        // The relation should take 4 args (2 structs × 2 fields each)
        assert!(ir_text.contains("define i32 @parent(i64 %arg0, i64 %arg1, i64 %arg2, i64 %arg3)"));

        // The fact should have 4 flattened values
        assert!(ir_text.contains("[4  x i64]"));

        // All 4 matches should be combined
        assert!(ir_text.contains("%match0"));
        assert!(ir_text.contains("%match1"));
        assert!(ir_text.contains("%match2"));
        assert!(ir_text.contains("%match3"));
        assert!(ir_text.contains("%match_all_3"));
    }

    #[test]
    fn test_codegen_string_deduplication() {
        use crate::parser;

        // Test that identical strings are deduplicated
        let source = r#"
            type Person = person(name: String, age: Int)
            rel parent: Person × Person
            parent(person("Alice", 45), person("Bob", 20)).
            ?- parent(person("Alice", 45), person("Bob", 20)).
        "#;
        let program = parser::parse(source).expect("Parse failed");

        let mut codegen = CodeGen::new();
        let ir = codegen.codegen_program(&program);
        assert!(ir.is_ok());

        let ir_text = ir.unwrap();

        // "Alice" should only appear once as a constant
        let alice_count = ir_text.matches("c\"Alice").count();
        assert_eq!(alice_count, 1, "String 'Alice' should be deduplicated");

        // "Bob" should only appear once as a constant
        let bob_count = ir_text.matches("c\"Bob").count();
        assert_eq!(bob_count, 1, "String 'Bob' should be deduplicated");
    }
}
